diff --git a/kernel/defs.h b/kernel/defs.h
index 59f7aae..6b13c2e 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -179,6 +179,10 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 int             test_pagetable();
+void            vmprint(pagetable_t );
+void            kvmmapkern(pagetable_t, uint64, uint64, uint64, int);
+pagetable_t     kvmcreate();
+void            kvmfree(pagetable_t, uint64);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index 7b8a524..43d427a 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -97,6 +97,7 @@ int exec(char *path, char **argv) {
   p->trapframe->sp = sp;          // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  if(p->pid==1) vmprint(p->pagetable);
   return argc;  // this ends up in a0, the first argument to main(argc, argv)
 
 bad:
diff --git a/kernel/proc.c b/kernel/proc.c
index 292ccb8..3d3590b 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -111,6 +111,8 @@ found:
     return 0;
   }
 
+  p->kernelpgtbl = kvmcreate();
+
   // Set up new context to start executing at forkret,
   // which returns to user space.
   memset(&p->context, 0, sizeof(p->context));
@@ -128,6 +130,10 @@ static void freeproc(struct proc *p) {
   p->trapframe = 0;
   if (p->pagetable) proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
+
+  if (p->kernelpgtbl) kvmfree(p->kernelpgtbl, p->sz);
+  p->kernelpgtbl = 0;
+
   p->sz = 0;
   p->pid = 0;
   p->parent = 0;
@@ -430,11 +436,16 @@ void scheduler(void) {
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+
+        w_satp(MAKE_SATP(p->kernelpgtbl));
+        sfence_vma();
+
         swtch(&c->context, &p->context);
 
         // Process is done running for now.
         // It should have changed its p->state before coming back.
         c->proc = 0;
+        kvminithart();
 
         found = 1;
       }
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..fba1770 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -103,4 +103,6 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+
+  pagetable_t kernelpgtbl;     // Kernel page table
 };
diff --git a/kernel/vm.c b/kernel/vm.c
index b794885..0287a97 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -172,6 +172,56 @@ pagetable_t uvmcreate() {
   return pagetable;
 }
 
+//part 2
+void 
+kvmmapkern(pagetable_t pagetable, uint64 va, uint64 pa, uint64 sz, int perm)
+{
+  if (mappages(pagetable, va, sz, pa, perm) != 0) 
+    panic("kvmmap");
+}
+
+// proc's version of kvminit
+pagetable_t
+kvmcreate() 
+{
+  pagetable_t pagetable;
+  int i;
+
+  pagetable = uvmcreate();
+  for(i = 1; i < 512; i++) {
+    pagetable[i] = kernel_pagetable[i];
+  }
+
+  // uart registers
+  kvmmapkern(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+  // virtio mmio disk interface
+  kvmmapkern(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+  // CLINT
+  kvmmapkern(pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);
+  // PLIC
+  kvmmapkern(pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+  
+  return pagetable;
+}
+
+
+void 
+kvmfree(pagetable_t kpagetale, uint64 sz) 
+{
+  pte_t pte = kpagetale[0];
+  pagetable_t level1 = (pagetable_t) PTE2PA(pte);
+  for (int i = 0; i < 512; i++) {
+    pte_t pte = level1[i];
+    if (pte & PTE_V) {
+      uint64 level2 = PTE2PA(pte);
+      kfree((void *) level2);
+      level1[i] = 0;
+    }
+  }
+  kfree((void *) level1);
+  kfree((void *) kpagetale);
+}
+
 // Load the user initcode into address 0 of pagetable,
 // for the very first process.
 // sz must be less than a page.
@@ -378,4 +428,51 @@ int test_pagetable() {
   uint64 gsatp = MAKE_SATP(kernel_pagetable);
   printf("test_pagetable: %d\n", satp != gsatp);
   return satp != gsatp;
+}
+
+void
+vmprint_recursive(pagetable_t pagetable, int level) 
+{
+  // 遍历512个页表项
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if(pte & PTE_V) { // 只处理有效的页表项
+      // 打印缩进
+      for(int j = 0; j < level; j++){
+        printf("||   ");
+      }
+      
+      uint64 child = PTE2PA(pte);
+      if((pte & (PTE_R|PTE_W|PTE_X)) == 0){ // 非叶节点
+        // 打印页表项信息
+        printf("||idx: %d: pa: %p, flags: ", i, child);
+        
+        // 用字符串方式打印权限标志
+        printf("%s", (pte & PTE_R) ? "r" : "-");
+        printf("%s", (pte & PTE_W) ? "w" : "-"); 
+        printf("%s", (pte & PTE_X) ? "x" : "-");
+        printf("%s\n", (pte & PTE_U) ? "u" : "-");
+        
+        // 递归处理下一级页表
+        vmprint_recursive((pagetable_t)child, level + 1);
+      } else { // 叶节点
+        // 计算虚拟地址
+        uint64 va = (uint64)i << (PXSHIFT(2-level));
+        printf("||idx: %d: va: %p -> pa: %p, flags: ", i, va, child);
+        
+        // 打印权限标志
+        printf("%s", (pte & PTE_R) ? "r" : "-");
+        printf("%s", (pte & PTE_W) ? "w" : "-");
+        printf("%s", (pte & PTE_X) ? "x" : "-");
+        printf("%s\n", (pte & PTE_U) ? "u" : "-");
+      }
+    }
+  }
+}
+
+void
+vmprint(pagetable_t pagetable)
+{
+  printf("page table %p\n", pagetable);
+  vmprint_recursive(pagetable, 0);
 }
\ No newline at end of file
diff --git a/user/sh.c b/user/sh.c
index 13c7d7c..6f1b5a8 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -54,6 +54,7 @@ void panic(char *);
 struct cmd *parsecmd(char *);
 
 // Execute cmd.  Never returns.
+__attribute__((noreturn))
 void runcmd(struct cmd *cmd) {
   int p[2];
   struct backcmd *bcmd;
